package business{	/**	 * RED5 Open Source Flash Server - http://www.osflash.org/red5	 *	 * Copyright (c) 2006-2009 by respective authors (see below). All rights reserved.	 *	 * This library is free software; you can redistribute it and/or modify it under the	 * terms of the GNU Lesser General Public License as published by the Free Software	 * Foundation; either version 2.1 of the License, or (at your option) any later	 * version.	 *	 * This library is distributed in the hope that it will be useful, but WITHOUT ANY	 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A	 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.	 *	 * You should have received a copy of the GNU Lesser General Public License along	 * with this library; if not, write to the Free Software Foundation, Inc.,	 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA	 */	import components.main.Body;		import events.FullStreamingEvent;		import flash.errors.IOError;	import flash.events.AsyncErrorEvent;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.net.NetConnection;	import flash.net.ObjectEncoding;		import model.DataModel;		import mx.rpc.IResponder;
	/**	 *	 * @author Thijs Triemstra, Babelium Team	 *	 */	public class NetConnectionDelegate extends EventDispatcher	{		private var _dataModel:DataModel=DataModel.getInstance();		private var responder:IResponder;		private var netConnection:NetConnection=_dataModel.netConnection;				private var uri:String;				private var encapsulateRTMP:Boolean=false;				private var proxy:String;				private var encoding:uint;		public function NetConnectionDelegate(res:IResponder)		{			_dataModel.netConnection=new NetConnection();			// Listen and capture the NetConnection info and error events.			responder=res;		}		/**		 *		 * @param uri		 * @param proxy		 * @param encoding		 */		public function connect(proxy:String, encoding:uint):void		{			this.proxy = proxy;			this.encoding = encoding;			//We check if another connect attempt is still ongoing			if (!_dataModel.netConnectOngoingAttempt)			{				_dataModel.netConnectOngoingAttempt = true;								// Initialize the NetConnection in the model.				if(_dataModel.netConnection)					_dataModel.netConnection=new NetConnection();				netConnection=_dataModel.netConnection;				netConnection.client=responder;				netConnection.objectEncoding=encoding;				netConnection.proxyType=proxy;				// Setup the NetConnection and listen for NetStatusEvent and SecurityErrorEvent events.				netConnection.addEventListener(NetStatusEvent.NET_STATUS, netStatus);				netConnection.addEventListener(AsyncErrorEvent.ASYNC_ERROR, netASyncError);				netConnection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, netSecurityError);				netConnection.addEventListener(IOErrorEvent.IO_ERROR, netIOError);				// connect to server				try				{					_dataModel.streamingProtocol = encapsulateRTMP ?  DataModel.RTMPT : DataModel.RTMP;					_dataModel.streamingPort = encapsulateRTMP ?  DataModel.RTMPT_PORT : DataModel.RTMP_PORT;					uri = _dataModel.streamingProtocol+"://"+_dataModel.server+":"+_dataModel.streamingPort+"/"+_dataModel.streamingApp;					trace("Connecting to " + uri);					// Create connection with the server.					netConnection.connect(uri);				}				catch (e:ArgumentError)				{					// Invalid parameters.					switch (e.errorID)					{						case 2004:							trace("Invalid server location: " + uri);							_dataModel.netConnectOngoingAttempt = false;							_dataModel.netConnected=false;							break;						default:							_dataModel.netConnectOngoingAttempt = false;							_dataModel.netConnected=false;							break;					}				}				catch (e:IOError)				{					_dataModel.netConnectOngoingAttempt = false;					_dataModel.netConnected=false;				}				catch (e:SecurityError)				{					_dataModel.netConnectOngoingAttempt = false;					_dataModel.netConnected=false;				}			}		}		/**		 *		 *		 */		public function close():void		{			// Close the NetConnection.			if(netConnection){				netConnection.close();			}		}		/**		 *		 * @param event		 */		protected function netStatus(event:NetStatusEvent):void		{			_dataModel.netConnectOngoingAttempt = false;						var info:Object=event.info;			var statusCode:String=info.code;						switch (statusCode)			{				case "NetConnection.Connect.Success":					//Set a flag in the model to denote the successful connection					_dataModel.netConnected=true;					dispatchEvent(new FullStreamingEvent(FullStreamingEvent.CONNECTION_READY));										// find out if it's a secure (HTTPS/TLS) connection					if (event.target.connectedProxyType == "HTTPS" || event.target.usingTLS)						trace("Connected to secure server");					else						trace("Connected to server");					trace("Protocol: "+_dataModel.streamingProtocol);					break;								case "NetConnection.Connect.Failed":					_dataModel.netConnected = false;					trace("Connection to server failed");					encapsulateRTMP = true;					connect(proxy,encoding);					break;								case "NetConnection.Connect.Closed":					_dataModel.netConnected = false;					trace("Connection to server closed");					break;								case "NetConnection.Connect.InvalidApp":					_dataModel.netConnected = false;					trace("Application not found on server");					break;								case "NetConnection.Connect.AppShutDown":					_dataModel.netConnected = false;					trace("Application has been shutdown");					break;								case "NetConnection.Connect.Rejected":					_dataModel.netConnected = false;					trace("No permissions to connect to the application");					break;								default:					// statements					break;			}									// Pass NetStatusEvent to SetupConnectionCommand.			this.responder.result(null);					}		/**		 *		 * @param event		 */		protected function netSecurityError(event:SecurityErrorEvent):void		{			_dataModel.netConnectOngoingAttempt = false;			// Pass SecurityErrorEvent to SetupConnectionCommand.			responder.fault(new SecurityErrorEvent(SecurityErrorEvent.SECURITY_ERROR, false, true, "Security error - " + event.text));		}		/**		 *		 * @param event		 */		protected function netIOError(event:IOErrorEvent):void		{			_dataModel.netConnectOngoingAttempt = false;			// Pass IOErrorEvent to SetupConnectionCommand.			responder.fault(new IOErrorEvent(IOErrorEvent.IO_ERROR, false, true, "Input/output error - " + event.text));		}		/**		 *		 * @param event		 */		protected function netASyncError(event:AsyncErrorEvent):void		{			_dataModel.netConnectOngoingAttempt = false;			// Pass AsyncErrorEvent to SetupConnectionCommand.			responder.fault(new AsyncErrorEvent(AsyncErrorEvent.ASYNC_ERROR, false, true, "Asynchronous code error - " + event.error));		}	}}
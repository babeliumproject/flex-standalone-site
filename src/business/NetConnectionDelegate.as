package business{	/**	 * RED5 Open Source Flash Server - http://www.osflash.org/red5	 *	 * Copyright (c) 2006-2009 by respective authors (see below). All rights reserved.	 *	 * This library is free software; you can redistribute it and/or modify it under the	 * terms of the GNU Lesser General Public License as published by the Free Software	 * Foundation; either version 2.1 of the License, or (at your option) any later	 * version.	 *	 * This library is distributed in the hope that it will be useful, but WITHOUT ANY	 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A	 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.	 *	 * You should have received a copy of the GNU Lesser General Public License along	 * with this library; if not, write to the Free Software Foundation, Inc.,	 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA	 */	import components.main.Body;		import events.FullStreamingEvent;		import flash.errors.IOError;	import flash.events.AsyncErrorEvent;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.net.NetConnection;	import flash.net.ObjectEncoding;		import model.DataModel;		import mx.rpc.IResponder;	/**	 *	 * @author Thijs Triemstra, Babelium Team	 *	 */	public class NetConnectionDelegate extends EventDispatcher	{		private var _dataModel:DataModel=DataModel.getInstance();		private var responder:IResponder;		private var netConnection:NetConnection=_dataModel.netConnection;		private var uri:String;		private var encapsulateRTMP:Boolean=false;		private var proxy:String;		private var encoding:uint;				private var url:String;				private var _signalclose:Boolean;		public function NetConnectionDelegate(res:IResponder)		{			_dataModel.netConnection=new NetConnection();			// Listen and capture the NetConnection info and error events.			responder=res;		}		/**		 *		 * @param uri		 * @param proxy		 * @param encoding		 */		public function connect(url:String, proxy:String, encoding:uint):void		{			this.url=url;			this.proxy=proxy;			this.encoding=encoding;			//We check if another connect attempt is still ongoing			if (!_dataModel.netConnectOngoingAttempt)			{				_dataModel.netConnectOngoingAttempt=true;				// Initialize the NetConnection in the model.				if (_dataModel.netConnection)					_dataModel.netConnection=new NetConnection();				netConnection=_dataModel.netConnection;				netConnection.client=responder;				netConnection.objectEncoding=encoding;				netConnection.proxyType=proxy;				// Setup the NetConnection and listen for NetStatusEvent and SecurityErrorEvent events.				netConnection.addEventListener(NetStatusEvent.NET_STATUS, netStatus, false, 0, true);				netConnection.addEventListener(AsyncErrorEvent.ASYNC_ERROR, netASyncError, false, 0, true);				netConnection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, netSecurityError, false, 0, true);				netConnection.addEventListener(IOErrorEvent.IO_ERROR, netIOError, false, 0, true);				// connect to server				try				{						uri=url;					trace("Connecting to " + uri);					// Create connection with the server.					netConnection.connect(uri);				}				catch (e:ArgumentError)				{					// Invalid parameters.					switch (e.errorID)					{						case 2004:							trace("Invalid server location: " + uri);							_dataModel.netConnectOngoingAttempt=false;							_dataModel.netConnected=false;							break;						default:							_dataModel.netConnectOngoingAttempt=false;							_dataModel.netConnected=false;							break;					}				}				catch (e:IOError)				{					_dataModel.netConnectOngoingAttempt=false;					_dataModel.netConnected=false;				}				catch (e:SecurityError)				{					_dataModel.netConnectOngoingAttempt=false;					_dataModel.netConnected=false;				}			}		}		/**		 *		 *		 */		public function close():void		{			if (netConnection)			{				if (netConnection.connected)				{					//Close an open connection					netConnection.close();				}				else				{					//Close handshaking connection					if(_dataModel.netConnectOngoingAttempt){						_signalclose=true;					} else {						netConnection.removeEventListener(NetStatusEvent.NET_STATUS, netStatus);						netConnection.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, netASyncError);						netConnection.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, netSecurityError);						netConnection.removeEventListener(IOErrorEvent.IO_ERROR, netIOError);					}				}			}		}		/**		 *		 * @param event		 */		protected function netStatus(event:NetStatusEvent):void		{			_dataModel.netConnectOngoingAttempt=false;			var info:Object=event.info;			var statusCode:String=info.code;						if(_signalclose){				netConnection.removeEventListener(NetStatusEvent.NET_STATUS, netStatus);				netConnection.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, netASyncError);				netConnection.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, netSecurityError);				netConnection.removeEventListener(IOErrorEvent.IO_ERROR, netIOError);				_dataModel.netConnected=false;				_dataModel.netConnectOngoingAttempt=false;				_signalclose=false;				return;			}			switch (statusCode)			{				case "NetConnection.Connect.Success":					//Set a flag in the model to denote the successful connection					_dataModel.netConnected=true;					// find out if it's a secure (HTTPS/TLS) connection					if (event.target.connectedProxyType == "HTTPS" || event.target.usingTLS)						trace("Connected to secure server");					else						trace("Connected to server");					trace("Protocol: " + _dataModel.streamingProtocol);					dispatchEvent(new FullStreamingEvent(FullStreamingEvent.CONNECTION_READY));					break;				case "NetConnection.Connect.Failed":					_dataModel.netConnected=false;					trace("Connection to server failed");					encapsulateRTMP=true;					connect(url, proxy, encoding);					break;				case "NetConnection.Connect.Closed":					_dataModel.netConnected=false;					_dataModel.netConnectOngoingAttempt=false;					netConnection.removeEventListener(NetStatusEvent.NET_STATUS, netStatus);					netConnection.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, netASyncError);					netConnection.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, netSecurityError);					netConnection.removeEventListener(IOErrorEvent.IO_ERROR, netIOError);					trace("Connection to server closed");					break;				case "NetConnection.Connect.InvalidApp":					_dataModel.netConnected=false;					trace("Application not found on server");					break;				case "NetConnection.Connect.AppShutDown":					_dataModel.netConnected=false;					trace("Application has been shutdown");					break;				case "NetConnection.Connect.Rejected":					_dataModel.netConnected=false;					trace("No permissions to connect to the application");					break;				default:					// statements					break;			}			// Pass NetStatusEvent to SetupConnectionCommand.			this.responder.result(null);		}		/**		 *		 * @param event		 */		protected function netSecurityError(event:SecurityErrorEvent):void		{			_dataModel.netConnectOngoingAttempt=false;			// Pass SecurityErrorEvent to SetupConnectionCommand.			responder.fault(new SecurityErrorEvent(SecurityErrorEvent.SECURITY_ERROR, false, true, "Security error - " + event.text));		}		/**		 *		 * @param event		 */		protected function netIOError(event:IOErrorEvent):void		{			_dataModel.netConnectOngoingAttempt=false;			// Pass IOErrorEvent to SetupConnectionCommand.			responder.fault(new IOErrorEvent(IOErrorEvent.IO_ERROR, false, true, "Input/output error - " + event.text));		}		/**		 *		 * @param event		 */		protected function netASyncError(event:AsyncErrorEvent):void		{			_dataModel.netConnectOngoingAttempt=false;			// Pass AsyncErrorEvent to SetupConnectionCommand.			responder.fault(new AsyncErrorEvent(AsyncErrorEvent.ASYNC_ERROR, false, true, "Asynchronous code error - " + event.error));		}	}}
package business{	/**	 * RED5 Open Source Flash Server - http://www.osflash.org/red5	 *	 * Copyright (c) 2006-2009 by respective authors (see below). All rights reserved.	 *	 * This library is free software; you can redistribute it and/or modify it under the	 * terms of the GNU Lesser General Public License as published by the Free Software	 * Foundation; either version 2.1 of the License, or (at your option) any later	 * version.	 *	 * This library is distributed in the hope that it will be useful, but WITHOUT ANY	 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A	 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.	 *	 * You should have received a copy of the GNU Lesser General Public License along	 * with this library; if not, write to the Free Software Foundation, Inc.,	 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA	 */			import flash.events.AsyncErrorEvent;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.media.Camera;	import flash.media.Microphone;	import flash.media.Video;	import flash.net.NetStream;		import model.DataModel;		import mx.rpc.IResponder;
		/**	 * 	 * @author Thijs Triemstra	 */		public class NetStreamDelegate	{					private var responder : IResponder;						private var service : Object;	 		 	//The two NetStreams used in the application				private var nsPublish : NetStream = DataModel.getInstance().media.nsPublish;			private var nsPlay : NetStream = DataModel.getInstance().media.nsPlay;					private var camera : Camera;				private var microphone : Microphone;				/**		 * 		 * @param res		 */				public function NetStreamDelegate( res : IResponder )		{			// Listen and capture the NetConnection info and error events.			responder = res;					}				/**		 * 		 * @param bufferTime		 * @param streamName		 * @param audio		 * @param video		 */						public function startPlayback( bufferTime : int, 									   streamName : String, 									   audio : Boolean,									   video : Boolean ) : void		{			try 			{				// Check for reconnect.				if ( nsPlay != null ) 				{					// Stop and close previous NetStream.					//var stopStreamEvent : StopStreamEvent = new StopStreamEvent();					//stopStreamEvent.dispatch();				}				// Setup NetStream for playback.				nsPlay = new NetStream( DataModel.getInstance().media.nc );				//				nsPlay.addEventListener( NetStatusEvent.NET_STATUS, netStatusEvent );				nsPlay.addEventListener( IOErrorEvent.IO_ERROR, netIOError );				nsPlay.addEventListener( AsyncErrorEvent.ASYNC_ERROR, netASyncError );				//				nsPlay.bufferTime = bufferTime;				nsPlay.receiveAudio( audio );				nsPlay.receiveVideo( video );				//				nsPlay.client = responder;				//				//				DataModel.getInstance().media.videoRemote = new Video( 320, 240 );				DataModel.getInstance().media.videoRemote.attachNetStream( nsPlay );				//				nsPlay.play( streamName );							}			catch( e : ArgumentError ) 			{				// Invalid parameters				switch ( e.errorID ) 				{					// NetStream object must be connected.					case 2126 :						//						trace( "Can't play stream, not connected to server");						break;					default :					   break;				}			}		}				/**		 * 		 */				public function stopPlayback() : void		{			if ( nsPlay != null ) 			{				// Close the NetStream.				nsPlay.close();			}		}				/**		 * Pause playback.		 */				public function pausePlayback() : void		{			// Pause the NetStream.			nsPlay.pause();		}				/**		 * Resume playback.		 */				public function resumePlayback() : void		{			// Resume playback for the NetStream.			nsPlay.resume();		}				/**		 * 		 * @param publishMode		 * @param streamName		 */				public function startPublish( publishMode : String, streamName : String ) : void		{			try 			{				camera = DataModel.getInstance().media.camera;				microphone = DataModel.getInstance().media.microphone;				//				if ( microphone != null || camera != null ) 				{					// close previous stream					if ( nsPublish != null ) 					{						// Stop and unpublish current NetStream.						//var unpublishStreamEvent : UnpublishStreamEvent = new UnpublishStreamEvent();						//unpublishStreamEvent.dispatch();					}					// Setup NetStream for publishing.					nsPublish = new NetStream( DataModel.getInstance().media.nc );					//					nsPublish.addEventListener( NetStatusEvent.NET_STATUS, netStatusEvent );					nsPublish.addEventListener( IOErrorEvent.IO_ERROR, netIOError );					nsPublish.addEventListener( AsyncErrorEvent.ASYNC_ERROR, netASyncError );					//					nsPublish.client = responder;						// attach devices to NetStream.					if ( camera != null ) 					{						nsPublish.attachCamera( camera );					}					if ( microphone != null) 					{						nsPublish.attachAudio( microphone );					}					// Start publishing.					nsPublish.publish( streamName, publishMode );				} 				else 				{					trace( "Can't publish stream, no input device(s) selected");					//				}			}			catch( e : ArgumentError ) 			{				// Invalid parameters				switch ( e.errorID ) 				{					// NetStream object must be connected.					case 2126 :						//						trace( "Can't publish stream, not connected to server");						break;					//					default :					   //					   trace( e.toString());					   break;				}			}		}				/**		 * 		 */				public function stopPublish() : void		{			//			nsPublish.close();		}				/**		 * 		 * @param enable		 */				public function enableAudio( enable : Boolean ) : void		{			//			nsPlay.receiveAudio( enable );		}				/**		 * 		 * @param enable		 */				public function enableVideo( enable : Boolean ) : void		{			//			nsPlay.receiveVideo( enable );		}					/**		 * 		 * @param event		 */				protected function netStatusEvent( event : NetStatusEvent ) : void 		{			// Pass NetStatusEvent to Command.			responder.result( event );		}				/**		 * 		 * @param event		 */				protected function netSecurityError( event : SecurityErrorEvent ) : void 		{			// Pass SecurityErrorEvent to Command.		    responder.fault( new SecurityErrorEvent ( SecurityErrorEvent.SECURITY_ERROR, false, true,		    										  "Security error - " + event.text ) );		}				/**		 * 		 * @param event		 */				protected function netIOError( event : IOErrorEvent ) : void 		{			// Pass IOErrorEvent to Command.			responder.fault( new IOErrorEvent ( IOErrorEvent.IO_ERROR, false, true, 							 "Input/output error - " + event.text ) );		}				/**		 * 		 * @param event		 */				protected function netASyncError( event : AsyncErrorEvent ) : void 		{			// Pass AsyncErrorEvent to Command.			responder.fault( new AsyncErrorEvent ( AsyncErrorEvent.ASYNC_ERROR, false, true,							 "Asynchronous code error - <i>" + event.error + "</i>" ) );		}		    }}
<?xml version="1.0" encoding="utf-8"?>

<!--

	ADOBE SYSTEMS INCORPORATED
	Copyright 2008 Adobe Systems Incorporated
	All Rights Reserved.

	NOTICE: Adobe permits you to use, modify, and distribute this file
	in accordance with the terms of the license agreement accompanying it.

-->

<!--- The default skin class for a Spark ToggleButton component.

	 @see spark.components.ToggleButton

	  @langversion 3.0
	  @playerversion Flash 10
	  @playerversion AIR 1.5
	  @productversion Flex 4
-->
<s:SparkSkin xmlns:fx="http://ns.adobe.com/mxml/2009"
			 xmlns:s="library://ns.adobe.com/flex/spark"
			 xmlns:fb="http://ns.adobe.com/flashbuilder/2009"
			 minWidth="21"
			 minHeight="21"
			 alpha.disabledStates="0.5">
	<fx:Metadata>[HostComponent("spark.components.ButtonBarButton")]</fx:Metadata>

	<!-- host component -->
	<fx:Script fb:purpose="styling">

		<![CDATA[
			import mx.utils.ArrayUtil;
			/* Define the skin elements that should not be colorized.
			   For toggle button, the graphics are colorized but the label is not. */
			static private const exclusions:Array=["labelDisplay"];


			private var fillgc:Array=[0xFFFFFF, 0xD8D8D8];
			private var fillgcSelectedUpStates:Array=[0xBBBDBD, 0x9FA0A1];
			private var fillgcDownStates:Array=[0xAAAAAA, 0x929496];
			private var fillgcOver:Array=[0xBBBDBD,0x9FA0A1];
			private var fillgcOverAndSelected:Array = [0xBBBDBD, 0x8E8F90];


			/**
			 * @private
			 */
			override public function get colorizeExclusions():Array
			{
				return exclusions;
			}

			/**
			 * @private
			 */
			override protected function initializationComplete():void
			{
				useChromeColor=true;
				super.initializationComplete();
			}

			/**
			 * @private
			 */
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				var skinState:String = currentState;
				trace(skinState);
				if(skinState == 'up'){
//					var gcd:Array=ArrayUtil.toArray(getStyle('gradientColorsDown'));
//					
//					if (gcd && !equalArrays(fillgcDownStates, gcd))
//						fillgcDownStates=gcd;
					fillGradientEntry1.color=fillgc[0];
					if (fillgc.length > 1)
						fillGradientEntry2.color=fillgc[1];
					else
						fillGradientEntry2.color=fillgc[0];
				}
				if(skinState == 'down' || skinState == 'downAndSelected')
				{
//					var gcd:Array=ArrayUtil.toArray(getStyle('gradientColorsDown'));
//
//					if (gcd && !equalArrays(fillgcDownStates, gcd))
//						fillgcDownStates=gcd;
					fillGradientEntry1.color=fillgcDownStates[0];
					if (fillgcDownStates.length > 1)
						fillGradientEntry2.color=fillgcDownStates[1];
					else
						fillGradientEntry2.color=fillgcDownStates[0];
				}
				if(skinState == 'upAndSelected' || skinState == 'disabledAndSelected'){
//					var gcd:Array=ArrayUtil.toArray(getStyle('gradientColorsDown'));
//					
//					if (gcd && !equalArrays(fillgcDownStates, gcd))
//						fillgcDownStates=gcd;
					fillGradientEntry1.color=fillgcSelectedUpStates[0];
					if (fillgcSelectedUpStates.length > 1)
						fillGradientEntry2.color=fillgcSelectedUpStates[1];
					else
						fillGradientEntry2.color=fillgcSelectedUpStates[0];
				}
				if(skinState == 'over'){
					//					var gcd:Array=ArrayUtil.toArray(getStyle('gradientColorsDown'));
					//					
					//					if (gcd && !equalArrays(fillgcDownStates, gcd))
					//						fillgcDownStates=gcd;
					fillGradientEntry1.color=fillgcOver[0];
					if (fillgcOver.length > 1)
						fillGradientEntry2.color=fillgcOver[1];
					else
						fillGradientEntry2.color=fillgcOver[0];
				}
				if(skinState == 'overAndSelected'){
					//					var gcd:Array=ArrayUtil.toArray(getStyle('gradientColorsDown'));
					//					
					//					if (gcd && !equalArrays(fillgcDownStates, gcd))
					//						fillgcDownStates=gcd;
					fillGradientEntry1.color=fillgcOverAndSelected[0];
					if (fillgcOverAndSelected.length > 1)
						fillGradientEntry2.color=fillgcOverAndSelected[1];
					else
						fillGradientEntry2.color=fillgcOverAndSelected[0];
				}

				var cr:Number=getStyle("cornerRadius");

				if (cornerRadius != cr)
				{
					cornerRadius=cr;
					shadow.radiusX=cornerRadius;
					fill.radiusX=cornerRadius;
					border.radiusX=cornerRadius;
				}



				super.updateDisplayList(unscaledWidth, unscaledHeight);
			}

			private var cornerRadius:Number=2;

			private function equalArrays(array1:Array, array2:Array):Boolean
			{
				var equivalent:Boolean=true;
				if (!array1 || !array2)
					return false;
				if (array1.length != array2.length)
					return false;
				for (var i:int=0; i < array1.length; i++)
				{
					if (array1[i] != array2[i])
					{
						equivalent=false;
						break;
					}
				}
				return equivalent;
			}
		]]>

	</fx:Script>

	<!-- states -->
	<s:states>
		<s:State name="up"/>
		<s:State name="over"
				 stateGroups="overStates"/>
		<s:State name="down"
				 stateGroups="downStates"/>
		<s:State name="disabled"
				 stateGroups="disabledStates"/>
		<s:State name="upAndSelected"
				 stateGroups="selectedStates, selectedUpStates"/>
		<s:State name="overAndSelected"
				 stateGroups="overStates, selectedStates"/>
		<s:State name="downAndSelected"
				 stateGroups="downStates, selectedStates"/>
		<s:State name="disabledAndSelected"
				 stateGroups="selectedUpStates, disabledStates, selectedStates"/>
	</s:states>

	<!-- layer 1: shadow -->
	<!--- @private -->
	<s:Rect id="shadow"
			left="-1"
			right="-1"
			top="-1"
			bottom="-1"
			radiusX="2">
		<s:fill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0x000000"
								 color.downStates="0xFFFFFF"
								 alpha="0.01"
								 alpha.downStates="0"/>
				<s:GradientEntry color="0x000000"
								 color.downStates="0xFFFFFF"
								 alpha="0.07"
								 alpha.downStates="0.5"/>
			</s:LinearGradient>
		</s:fill>
	</s:Rect>

	<!-- layer 2: fill -->
	<!--- @private -->
	<s:Rect id="fill"
			left="1"
			right="1"
			top="1"
			bottom="1"
			radiusX="2">
		<s:fill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry id="fillGradientEntry1"
								 alpha="0.85"
								 alpha.overAndSelected="1"/>
				<s:GradientEntry id="fillGradientEntry2"
								 alpha="0.85"
								 alpha.overAndSelected="1"/>
			</s:LinearGradient>
		</s:fill>
	</s:Rect>

	<!-- layer 7: border - put on top of the fill so it doesn't disappear when scale is less than 1 -->
	<!--- @private -->
	<s:Rect id="border"
			left="0"
			right="0"
			top="0"
			bottom="0"
			width="69"
			height="20"
			radiusX="2">
		<s:stroke>
			<s:LinearGradientStroke rotation="90"
									weight="1">
				<s:GradientEntry color="0x000000"
								 alpha="0.5625"
								 alpha.down="0.6375"
								 alpha.selectedStates="0.6375"/>
				<s:GradientEntry color="0x000000"
								 alpha="0.75"
								 alpha.down="0.85"
								 alpha.selectedStates="0.85"/>
			</s:LinearGradientStroke>
		</s:stroke>
	</s:Rect>

	<!-- layer 8: text -->
	<!--- @copy spark.components.supportClasses.ButtonBase#labelDisplay -->
	<s:Label id="labelDisplay"
			 textAlign="center"
			 verticalAlign="middle"
			 maxDisplayedLines="1"
			 horizontalCenter="0"
			 verticalCenter="1"
			 left="10"
			 right="10"
			 top="2"
			 bottom="2">
	</s:Label>

</s:SparkSkin>

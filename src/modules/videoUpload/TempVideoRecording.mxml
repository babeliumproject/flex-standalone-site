<?xml version="1.0" encoding="utf-8"?>
<mx:HBox xmlns:mx="http://www.adobe.com/2006/mxml"
		 borderStyle="solid"
		 borderThickness="2"
		 creationComplete="onComplete()"
		 cornerRadius="4">

	<mx:Metadata>
		[ResourceBundle("myResources")]
	</mx:Metadata>

	<mx:Script>

		<![CDATA[
			import model.DataModel;
			
			import mx.controls.Text;
			import mx.core.Application;
			import mx.events.CloseEvent;
			import mx.managers.PopUpManager;
			
			import view.common.CustomAlert;
			import view.common.PrivacyRights;
			import view.common.TimeFormatter;
			

			/**
			 *  Constants
			 */
			private const COUNTDOWN_TIMER_SECS:int=5; //seconds
			private const MAXIMUM_VIDEO_DURATION:int = 120; //seconds
			private const MINIMUM_VIDEO_DURATION:int = 15; //seconds
			private const DEFAULT_VIDEO_WIDTH:int = 320; //pixels
			private const DEFAULT_VIDEO_HEIGHT:int = 240; //pixels

			/**
			 *  Variable definition
			 */
			private var netConnection:NetConnection;

			private var publishNetStream:NetStream;
			private var playbackNetStream:NetStream;

			[Bindable]
			public var recordingFileName:String;
			
			[Bindable]
			public var isRecording:Boolean;

			private var audio_pause:Boolean;


			private var video:Video;
			[Bindable]
			private var _videoHeight:int = DEFAULT_VIDEO_HEIGHT;
			[Bindable]
			private var _videoWidth:int = DEFAULT_VIDEO_WIDTH;

			private var _camera:Camera;
			private var _mic:Microphone;
			private var _micCamEnabled:Boolean=false;
			
			private var _streamingServerConnection:Boolean = false;
			private var _streamsFolder:String = '';
			private var _streamFilePrefix:String = '';
			
			private var _countdown:Timer;
			private var _countdownTxt:Text;
			
			private var _recordCountDown:Timer;

			private var privacyRights:PrivacyRights;

			private var anyContent:Boolean;
			
			private var _timeFormatter:TimeFormatter;

			[Embed(source='../../resources/images/playerPlayIcon.png')]
			[Bindable]
			private var playImageEmbed:Class;
			[Embed(source='../../resources/images/playerPauseIcon.png')]
			[Bindable]
			private var pauseImageEmbed:Class;
			[Embed(source='../../resources/images/playerRecIcon.png')]
			[Bindable]
			private var recImageEmbed:Class;
			[Embed(source='../../resources/images/playerStopIcon.png')]
			[Bindable]
			private var stopImageEmbed:Class;



			public function onComplete():void
			{
				//Button icon initialization
				recStopButton.setStyle('icon', recImageEmbed);
				playPauseButton.setStyle('icon', playImageEmbed);
				
				_timeFormatter = new TimeFormatter();
				_timeFormatter.outputMilliseconds = false;
				
				_countdownTxt=new Text();
				_countdownTxt.text="5";
				_countdownTxt.setStyle("fontWeight", "bold");
				_countdownTxt.setStyle("fontSize", 30);
				_countdownTxt.setStyle("color", 0xFFFFFF);
				_countdownTxt.selectable=false;
				_countdownTxt.visible=false;
				
				
				_countdownTxt.x=_videoWidth / 2 - 10;
				_countdownTxt.y=_videoHeight / 2 - 10;
				_countdownTxt.width=_videoWidth;
				_countdownTxt.height=_videoHeight;

				anyContent=false;
				audio_pause=false;
				isRecording=false;
			}
			
			public function resetComponent():void{
				recStopButton.setStyle('icon', recImageEmbed);
				playPauseButton.setStyle('icon', playImageEmbed);
				playPauseButton.enabled = false;
				
				anyContent=false;
				audio_pause=false;
				isRecording=false;

				recordingFileName = null;
				
				if(publishNetStream)
					publishNetStream.close();
				if(playbackNetStream)
					playbackNetStream.close();
				if(netConnection)
					netConnection.close();
				if(video)
				{
					video.attachCamera(null);
					video.clear();
				}
				
				_streamingServerConnection = false;
			}
			
			public function set streamsFolder(folder:String):void{
				_streamsFolder = folder;
			}
			
			public function get streamsFolder():String{
				return _streamsFolder;
			}
			
			public function set filePrefix(prefix:String):void{
				_streamFilePrefix = prefix;
			}
			
			public function get filePrefix():String{
				return _streamFilePrefix;
			}
			
			private function connectToStreamingServer():void{
				netConnection=new NetConnection();
				netConnection.connect(DataModel.getInstance().streamingResourcesPath);
				netConnection.addEventListener(NetStatusEvent.NET_STATUS, connectionNetStatusHandler);
				netConnection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, netSecurityError);
				netConnection.client=this;
			}

			private function connectionNetStatusHandler(event:NetStatusEvent):void
			{
				var info:Object=event.info;
				switch (info.code)
				{
					case "NetConnection.Connect.Success":
						// Close and recreate streams
						if (playbackNetStream)
							playbackNetStream.close();
						if (publishNetStream)
							publishNetStream.close();

						playbackNetStream=new NetStream(netConnection);
						publishNetStream=new NetStream(netConnection);

						playbackNetStream.addEventListener(NetStatusEvent.NET_STATUS, playbackStreamNetStatusHandler);

						playbackNetStream.client=this; // onPlayStatus
						playbackNetStream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler); // onMetaData
						
						_streamingServerConnection = true;
						
						prepareDevices();
						
						break;

					case "NetConnection.Connect.Closed":
						if (playbackNetStream)
							playbackNetStream.close();
						if (publishNetStream)
							publishNetStream.close();
						
						_streamingServerConnection = false;
						
						break;
					default:
						trace("NetConnection Error: "+info.code);
						CustomAlert.error("Error while connecting to the streaming server. Please try again later.");
						_streamingServerConnection = false;
						
						break;
				}
			}

			private function playbackStreamNetStatusHandler(event:NetStatusEvent):void
			{
				var info:Object=event.info;

				if (info.code == "NetStream.Play.Stop")
				{
					recStopButton.setStyle('icon', recImageEmbed);
					playPauseButton.setStyle('icon', playImageEmbed);
					
					recStopButton.enabled=true;
					playPauseButton.enabled=true;

					audio_pause=false;
				}
			}

			private function netSecurityError(event:SecurityErrorEvent):void
			{
				trace("netSecurityError: " + event);
			}

			private function playAudio():void
			{
				if (audio_pause)
				{
					playbackNetStream.resume();
					estat.text="*Playing...";
					audio_pause=false;
				}
				else
				{
					// Play the recording
					estat.text="Playing...";
					if (playbackNetStream)
						playbackNetStream.close();
					playbackNetStream=new NetStream(netConnection);
					playbackNetStream.addEventListener(NetStatusEvent.NET_STATUS, playbackStreamNetStatusHandler);
					playbackNetStream.client=this; // onPlayStatus
					playbackNetStream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler); // onMetaData

					playbackNetStream.play(_streamsFolder+"/"+recordingFileName);
					video.attachNetStream(playbackNetStream); // JUANAN
					estat.text="Playing...";
				}

				// It's not possible recording or save while audio is playing
				playPauseButton.enabled=true;
				recStopButton.enabled=true;

				recStopButton.setStyle('icon', stopImageEmbed);
				playPauseButton.setStyle('icon', pauseImageEmbed);
			}

			private function pauseAudio():void
			{
				//in_ns.togglePause();
				playbackNetStream.pause();
				estat.text="Paused";
				audio_pause=true;

				// It's possible recording or save while audio is paused
				recStopButton.enabled=true;
				playPauseButton.enabled=true;


				recStopButton.setStyle('icon', recImageEmbed);
				playPauseButton.setStyle('icon', playImageEmbed);
			}

			private function stopAudio():void
			{
				estat.text="Stopped ";

				// Close output stream
				publishNetStream.close();
				isRecording = false;

				// It's not possible playing audio while recording
				recStopButton.enabled=true;
				playPauseButton.enabled=true;

				recStopButton.setStyle('icon', recImageEmbed);
				playPauseButton.setStyle('icon', playImageEmbed);
			}

			private function recStopAudio():void
			{
				if(_streamingServerConnection == false)
				{
					connectToStreamingServer();
				} else {
					if (recStopButton.getStyle('icon') == recImageEmbed)
					{
						prepareDevices();
					}
					else
					{
						if(_recordCountDown.running){
							_recordCountDown.stop();
							_recordCountDown.reset();
							recordCountdown.text = _timeFormatter.format(0);
							recordCountdown.visible = false;
						}
						stopCamera();
						stopAudio();
					}
				}
			}

			private function stopCamera():void
			{
				// clear the videoContainer
				video.attachCamera(null);
				video.clear();
			}


			private function playPauseAudio():void
			{
				estat.text='playPauseAudio' + playPauseButton.label;
				switch (playPauseButton.getStyle('icon'))
				{
					case playImageEmbed:
						playAudio();
						break;
					case pauseImageEmbed:
						pauseAudio();
						break;
				}
			}

			public function onBWDone():void
			{
				trace("BWworked");
			}

			public function onPlayStatus(o:Object):void
			{
				if (o.code == "NetStream.Play.Complete")
				{
					estat.text="";

				}
			}

			public function asyncErrorHandler(event:AsyncErrorEvent):void
			{
				// ignore for now
			}

			private function prepareRecording():void
			{
				if (_micCamEnabled)
				{
					if (_camera != null)
					{
						videoHolder.setActualSize(_camera.width, _camera.height);
						video=new Video(_camera.width, _camera.height);
						if (publishNetStream != null)
							publishNetStream.attachCamera(_camera);
						video.attachCamera(_camera);

						videoHolder.addChild(video);
						videoHolder.addChild(_countdownTxt);
						video.visible=false;
						_countdownTxt.visible=true;
						trace("All added you should see video");
					}
					if (_mic != null)
					{
						estat.text="Recording..."
						anyContent=true;

						_mic.setLoopBack(false);
						_mic.gain=40;

						// Start publishing the audio output as a recorded stream
						if(publishNetStream != null)
							publishNetStream.attachAudio(_mic);

						// It's not possible playing audio while recording
						recStopButton.enabled=true;
						recStopButton.setStyle('icon', stopImageEmbed);

						playPauseButton.enabled=false;
						playPauseButton.setStyle('icon', playImageEmbed);
						recStopButton.enabled = false;
					}
				}
			}
			
			private function startRecordCountDown():void{
				_recordCountDown=new Timer(1000, MAXIMUM_VIDEO_DURATION);
				_recordCountDown.addEventListener(TimerEvent.TIMER, onRecordCountDownTick);
				_recordCountDown.start();
			}
			
			private function onRecordCountDownTick(tick:TimerEvent):void{
				
				recordCountdown.text = _timeFormatter.format( MAXIMUM_VIDEO_DURATION - _recordCountDown.currentCount);
				if(_recordCountDown.currentCount >= MINIMUM_VIDEO_DURATION){
					recStopButton.enabled = true;
				}
				if(_recordCountDown.currentCount == _recordCountDown.repeatCount){
					//Maximum recording time elapsed stop recording at this point
					_recordCountDown.stop();
					_recordCountDown.reset();
					recordCountdown.text = _timeFormatter.format(0);
					recordCountdown.visible = false;
					recStopAudio();
				}
			}
			
			// Prepare countdown timer
			private function startCountdown():void
			{
				_countdown=new Timer(1000, COUNTDOWN_TIMER_SECS)
				_countdown.addEventListener(TimerEvent.TIMER, onCountdownTick);
				_countdown.start();
			}
			
			// On Countdown tick
			private function onCountdownTick(tick:TimerEvent):void
			{
				if (_countdown.currentCount == _countdown.repeatCount)
				{
					_countdownTxt.visible=false;
					video.visible=true;
					
					// Reset countdown timer
					_countdownTxt.text="5";
					_countdown.stop();
					_countdown.reset();
					
					startRecording();
				}
				else
					_countdownTxt.text=new String(5 - _countdown.currentCount);
			}

			private function startRecording():void
			{
				var d:Date=new Date();
				recordingFileName=_streamFilePrefix+"-"+d.getTime().toString();

				// Publish the stream
				publishNetStream.publish(_streamsFolder+"/"+recordingFileName, "record");
				isRecording = true;
				
				//Recording time elpased variables
				recordCountdown.visible = true;
				startRecordCountDown();
			}

			private function prepareDevices():void
			{
				if (DataModel.getInstance().micCamAllowed && DataModel.getInstance().microphone != null && DataModel.getInstance().camera != null)
				{
					_micCamEnabled = DataModel.getInstance().micCamAllowed;
					configureDevices();
				}
				else
				{
					PrivacyRights.useMicAndCamera = true;
					privacyRights=PrivacyRights(PopUpManager.createPopUp(Application.application.parent, PrivacyRights, true));
					privacyRights.addEventListener(CloseEvent.CLOSE, privacyBoxClosed);
					PopUpManager.centerPopUp(privacyRights);
				}
			}

			private function configureDevices():void
			{
				_camera=DataModel.getInstance().camera;
				_mic=DataModel.getInstance().microphone;
				_mic.setUseEchoSuppression(true);
				_mic.setLoopBack(true);
				_mic.setSilenceLevel(0, 60000);

				prepareRecording();
				startCountdown();
			}

			private function privacyBoxClosed(event:Event):void
			{
				PopUpManager.removePopUp(privacyRights);
				_micCamEnabled=DataModel.getInstance().micCamAllowed;
				if (_micCamEnabled && PrivacyRights.cameraFound && PrivacyRights.microphoneFound)
				{
					configureDevices();
				}
				else
				{
					CustomAlert.error("In order to record something you must 'Allow' the access to your devices.");
				}
			}
		]]>
	</mx:Script>

	<mx:VBox width="100%"
			 height="100%"
			 horizontalAlign="center">
		<mx:HBox paddingBottom="4"
				 paddingTop="4"
				 paddingLeft="4"
				 paddingRight="4">
			<mx:HBox backgroundColor="0x000000"
					 width="100%">
				<mx:UIComponent id="videoHolder"
								width="{_videoWidth}"
								height="{_videoHeight}"/>
			</mx:HBox>
		</mx:HBox>

		<mx:HBox width="100%"
				 horizontalAlign="left"
				 verticalAlign="center"
				 horizontalGap="4"
				 backgroundColor="0xCCCCCC"
				 paddingBottom="2"
				 paddingTop="2"
				 paddingLeft="4"
				 paddingRight="4">
			<mx:Button click="recStopAudio();"
					   id="recStopButton"
					   width="20"
					   height="20"
					   cornerRadius="4"/>
			<mx:Button click="playPauseAudio();"
					   id="playPauseButton"
					   enabled="false"
					   width="20"
					   height="20"
					   cornerRadius="4"/>
			<mx:Label id="statusLabel"
				text="Status:"
					  fontWeight="bold"/>
			<mx:Label id="estat"
					  width="100%"/>
			<mx:HBox width="100%" horizontalAlign="right">
				<mx:Label id="recordCountdown" visible="false" text=""/>
			</mx:HBox>
		</mx:HBox>
	</mx:VBox>


</mx:HBox>

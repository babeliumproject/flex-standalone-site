<?xml version="1.0" encoding="utf-8"?>
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009"
		  xmlns:s="library://ns.adobe.com/flex/spark"
		  xmlns:mx="library://ns.adobe.com/flex/mx"
		  xmlns:skins="skins.*"
		  creationComplete="onComplete()"
		  width="100%"
		  height="100%"
		  horizontalAlign="center">

	<fx:Script>

		<![CDATA[
			import events.CloseConnectionEvent;
			import events.StartConnectionEvent;

			import model.DataModel;

			import mx.binding.utils.BindingUtils;
			import mx.binding.utils.ChangeWatcher;
			import mx.controls.Text;
			import mx.core.Application;
			import mx.core.FlexGlobals;
			import mx.events.CloseEvent;
			import mx.managers.PopUpManager;

			import skins.IconButtonSkin;

			import view.common.CustomAlert;
			import view.common.PrivacyRights;
			import view.common.TimeFormatter;


			/**
			 *  Constants
			 */
			private const COUNTDOWN_TIMER_SECS:int=5; //seconds
			private const DEFAULT_MIC_GAIN:uint=70;
			private var _maximumVideoDuration:int=DataModel.getInstance().maxExerciseDuration; //seconds
			private var _minimumVideoDuration:int=DataModel.getInstance().minExerciseDuration; //seconds
			private var _defaultVideoWidth:int=DataModel.getInstance().cameraWidth; //pixels
			private var _defaultVideoHeight:int=DataModel.getInstance().cameraHeight; //pixels

			/**
			 *  Variable definition
			 */
			private var netConnection:NetConnection;

			private var publishNetStream:NetStream;
			private var playbackNetStream:NetStream;

			[Bindable]
			public var recordingFileName:String;

			[Bindable]
			public var isRecording:Boolean;

			private var audio_pause:Boolean;


			private var video:Video;
			[Bindable]
			private var _videoHeight:int=_defaultVideoHeight;
			[Bindable]
			private var _videoWidth:int=_defaultVideoWidth;

			private var _camera:Camera;
			private var _mic:Microphone;
			private var _micCamEnabled:Boolean=false;

			private var _streamingServerConnection:Boolean=false;
			private var _streamsFolder:String='';
			private var _streamFilePrefix:String='';

			private var _countdown:Timer;
			private var _countdownTxt:Text;

			private var _recordCountDown:Timer;

			private var privacyRights:PrivacyRights;

			private var anyContent:Boolean;

			private var _timeFormatter:TimeFormatter;

			[Embed(source='../../../resources/images/playerPlayIcon.png')]
			[Bindable]
			private var playImageEmbed:Class;
			[Embed(source='../../../resources/images/playerPauseIcon.png')]
			[Bindable]
			private var pauseImageEmbed:Class;
			[Embed(source='../../../resources/images/playerRecIcon.png')]
			[Bindable]
			private var recImageEmbed:Class;
			[Embed(source='../../../resources/images/playerStopIcon.png')]
			[Bindable]
			private var stopImageEmbed:Class;



			public function onComplete():void
			{
				//Button icon initialization
				startStopCapture.setStyle('icon', recImageEmbed);
				playPauseButton.setStyle('icon', playImageEmbed);

				_timeFormatter=new TimeFormatter();
				_timeFormatter.outputMilliseconds=false;

				_countdownTxt=new Text();
				_countdownTxt.text="5";
				_countdownTxt.setStyle("fontWeight", "bold");
				_countdownTxt.setStyle("fontSize", 30);
				_countdownTxt.setStyle("color", 0xFFFFFF);
				_countdownTxt.selectable=false;
				_countdownTxt.visible=false;

				anyContent=false;
				audio_pause=false;
				isRecording=false;

			}

			public function resetComponent():void
			{
				startStopCapture.setStyle('icon', recImageEmbed);
				startStopCapture.label=resourceManager.getString('myResources', 'START_RECORDING');
				startStopCapture.enabled=true;
				playPauseButton.setStyle('icon', playImageEmbed);
				playPauseButton.enabled=false;

				anyContent=false;
				audio_pause=false;
				isRecording=false;

				recordingFileName=null;

				if (_countdown && _countdown.running)
				{
					_countdown.stop();
					_countdown.reset();
					_countdownTxt.text=COUNTDOWN_TIMER_SECS.toString();
					_countdownTxt.visible=false;
				}

				disconnnectStreams();
			}

			public function set minimumVideoDuration(duration:uint):void
			{
				_minimumVideoDuration=duration;
			}

			public function set streamsFolder(folder:String):void
			{
				_streamsFolder=folder;
			}

			public function get streamsFolder():String
			{
				return _streamsFolder;
			}

			public function set filePrefix(prefix:String):void
			{
				_streamFilePrefix=prefix;
			}

			public function get filePrefix():String
			{
				return _streamFilePrefix;
			}

			private function connectToStreamingServer():void
			{
				if (DataModel.getInstance().netConnection.connected == false)
					new StartConnectionEvent(DataModel.getInstance().streamingResourcesPath).dispatch();
				else
					onConnectionStatus=false;
			}

			private function disconnectFromStreamingServer():void
			{
				if (DataModel.getInstance().netConnection.connected)
					new CloseConnectionEvent().dispatch();
			}

			private function disconnnectStreams():void
			{
				if (playbackNetStream)
					playbackNetStream.close();
				if (publishNetStream)
				{
					publishNetStream.attachCamera(null);
					publishNetStream.attachAudio(null);
					publishNetStream.close();
				}
				if (video)
				{
					video.clear();
					video.attachCamera(null);
					video=null;
				}
			}

			private function set onConnectionStatus(value:Boolean):void
			{
				if (DataModel.getInstance().netConnected == true)
				{

					//Get the netConnection reference
					netConnection=DataModel.getInstance().netConnection;
					_streamingServerConnection=true;

					if (playbackNetStream)
						playbackNetStream.close();
					if (publishNetStream)
						publishNetStream.close();

					playbackNetStream=new NetStream(netConnection);
					publishNetStream=new NetStream(netConnection);

					playbackNetStream.addEventListener(NetStatusEvent.NET_STATUS, playbackStreamNetStatusHandler);

					playbackNetStream.client=this; // onPlayStatus
					playbackNetStream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler); // onMetaData

				}
				else
				{
					if (playbackNetStream)
						playbackNetStream.close();
					if (publishNetStream)
					{
						publishNetStream.attachCamera(null);
						publishNetStream.attachAudio(null);
						publishNetStream.close();
					}
					if (video)
					{
						video.attachCamera(null);
						video.clear();
					}
					_streamingServerConnection=false;
				}
			}

			private function playbackStreamNetStatusHandler(event:NetStatusEvent):void
			{
				var info:Object=event.info;

				if (info.code == "NetStream.Play.Stop")
				{
					startStopCapture.setStyle('icon', recImageEmbed);
					playPauseButton.setStyle('icon', playImageEmbed);

					startStopCapture.enabled=true;
					playPauseButton.enabled=true;

					audio_pause=false;
				}
			}

			private function playAudio():void
			{
				if (audio_pause)
				{
					playbackNetStream.resume();
					audio_pause=false;
				}
				else
				{
					// Play the recording

					if (playbackNetStream)
						playbackNetStream.close();
					playbackNetStream=new NetStream(netConnection);
					playbackNetStream.addEventListener(NetStatusEvent.NET_STATUS, playbackStreamNetStatusHandler);
					playbackNetStream.client=this; // onPlayStatus
					playbackNetStream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler); // onMetaData

					playbackNetStream.play(_streamsFolder + "/" + recordingFileName);
					video.attachNetStream(playbackNetStream); // JUANAN

				}

				// It's not possible recording or save while audio is playing
				playPauseButton.enabled=true;
				startStopCapture.enabled=true;

				startStopCapture.setStyle('icon', stopImageEmbed);
				playPauseButton.setStyle('icon', pauseImageEmbed);
			}

			private function pauseAudio():void
			{
				//in_ns.togglePause();
				playbackNetStream.pause();

				audio_pause=true;

				// It's possible recording or save while audio is paused
				startStopCapture.enabled=true;
				playPauseButton.enabled=true;


				startStopCapture.setStyle('icon', recImageEmbed);
				playPauseButton.setStyle('icon', playImageEmbed);
			}

			private function stopAudio():void
			{
				// Close output stream
				if (publishNetStream)
				{
					publishNetStream.attachAudio(null);
					publishNetStream.close();
				}
				isRecording=false;

				// It's not possible playing audio while recording
				startStopCapture.enabled=true;
				playPauseButton.enabled=true;

				startStopCapture.setStyle('icon', recImageEmbed);
				playPauseButton.setStyle('icon', playImageEmbed);
			}

			private function startStopRecording():void
			{
				if (!_streamingServerConnection)
					connectToStreamingServer();
				if (!isRecording)
				{
					startStopCapture.label=resourceManager.getString('myResources', 'STOP');
					prepareDevices();
				}
				else
				{
					if (_recordCountDown.running)
					{
						_recordCountDown.stop();
						_recordCountDown.reset();
						recordCountdown.text=_timeFormatter.format(0);
						recordCountdown.visible=false;
					}
					stopCamera();
					stopAudio();
					if (recordingFileName)
					{
						startStopCapture.label=resourceManager.getString('myResources', 'RECORD_AGAIN');
					}
					else
					{
						startStopCapture.label=resourceManager.getString('myResources', 'START_RECORDING');
					}
				}
			}

			private function stopCamera():void
			{
				// clear the videoContainer
				video.clear();
				video.attachCamera(null);
				video=null;
				if (publishNetStream)
					publishNetStream.attachCamera(null);
			}


			private function playPauseRecording():void
			{
				switch (playPauseButton.getStyle('icon'))
				{
					case playImageEmbed:
						playAudio();
						break;
					case pauseImageEmbed:
						pauseAudio();
						break;
				}
			}

			public function onPlayStatus(o:Object):void
			{
				if (o.code == "NetStream.Play.Complete")
				{
					trace("Playback complete");
				}
			}

			public function asyncErrorHandler(event:AsyncErrorEvent):void
			{
				// ignore for now
			}

			private function prepareRecording():void
			{
				if (_micCamEnabled)
				{
					if (_camera != null)
					{
						//videoHolder.setActualSize(_camera.width, _camera.height);
						video=new Video(_camera.width, _camera.height);
						if (publishNetStream != null)
							publishNetStream.attachCamera(_camera);
						video.attachCamera(_camera);
						video.smoothing=true;
						video.height=videoHolder.height;
						video.width=videoHolder.width;

						_countdownTxt.x=videoHolder.width / 2 - 10;
						_countdownTxt.y=videoHolder.height / 2 - 10;
						_countdownTxt.width=videoHolder.width;
						_countdownTxt.height=videoHolder.height;

						videoHolder.addChild(video);
						videoHolder.addChild(_countdownTxt);
						video.visible=false;
						_countdownTxt.visible=true;
					}
					if (_mic != null)
					{
						anyContent=true;

						_mic.setLoopBack(false);
						_mic.gain=DEFAULT_MIC_GAIN;

						// Start publishing the audio output as a recorded stream
						if (publishNetStream != null)
							publishNetStream.attachAudio(_mic);

						// It's not possible playing audio while recording
						startStopCapture.enabled=true;
						startStopCapture.setStyle('icon', stopImageEmbed);

						playPauseButton.enabled=false;
						playPauseButton.setStyle('icon', playImageEmbed);
						startStopCapture.enabled=false;
					}
				}
			}

			private function startRecordCountDown():void
			{
				_recordCountDown=new Timer(1000, _maximumVideoDuration);
				_recordCountDown.addEventListener(TimerEvent.TIMER, onRecordCountDownTick);
				_recordCountDown.start();
			}

			private function onRecordCountDownTick(tick:TimerEvent):void
			{

				recordCountdown.text=_timeFormatter.format(_maximumVideoDuration - _recordCountDown.currentCount);
				if (_recordCountDown.currentCount >= _minimumVideoDuration)
				{
					startStopCapture.enabled=true;
				}
				if (_recordCountDown.currentCount == _recordCountDown.repeatCount)
				{
					//Maximum recording time elapsed stop recording at this point
					_recordCountDown.stop();
					_recordCountDown.reset();
					recordCountdown.text=_timeFormatter.format(0);
					recordCountdown.visible=false;
					startStopRecording();
				}
			}

			// Prepare countdown timer
			private function startCountdown():void
			{
				_countdown=new Timer(1000, COUNTDOWN_TIMER_SECS)
				_countdown.addEventListener(TimerEvent.TIMER, onCountdownTick);
				_countdown.start();
			}

			// On Countdown tick
			private function onCountdownTick(tick:TimerEvent):void
			{
				if (_countdown.currentCount == _countdown.repeatCount)
				{
					_countdownTxt.visible=false;
					video.visible=true;

					// Reset countdown timer
					_countdownTxt.text="5";
					_countdown.stop();
					_countdown.reset();

					startRecording();
				}
				else
					_countdownTxt.text=new String(5 - _countdown.currentCount);
			}

			private function startRecording():void
			{
				if (publishNetStream)
				{
					var d:Date=new Date();
					recordingFileName=_streamFilePrefix + "-" + d.getTime().toString();

					// Publish the stream
					publishNetStream.publish(_streamsFolder + "/" + recordingFileName, "record");
					isRecording=true;

					//Recording time elpased variables
					recordCountdown.visible=true;
					startRecordCountDown();
				}
			}

			private function prepareDevices():void
			{
				if (PrivacyRights.cameraReady() && PrivacyRights.microphoneReady())
				{
					_micCamEnabled=DataModel.getInstance().micCamAllowed;
					configureDevices();
				}
				else
				{
					PrivacyRights.useMicAndCamera=true;
					privacyRights=PrivacyRights(PopUpManager.createPopUp(FlexGlobals.topLevelApplication.parent, PrivacyRights, true));
					privacyRights.addEventListener(CloseEvent.CLOSE, privacyBoxClosed);
					PopUpManager.centerPopUp(privacyRights);
				}
			}

			private function configureDevices():void
			{
				_camera=DataModel.getInstance().camera;
				_camera.setMode(DataModel.getInstance().cameraWidth, DataModel.getInstance().cameraHeight, 15, false);
				_mic=DataModel.getInstance().microphone;
				_mic.setUseEchoSuppression(true);
				_mic.setLoopBack(true);
				_mic.setSilenceLevel(0, 60000);

				prepareRecording();
				startCountdown();
			}

			private function privacyBoxClosed(event:Event):void
			{
				PopUpManager.removePopUp(privacyRights);
				_micCamEnabled=DataModel.getInstance().micCamAllowed;
				if (_micCamEnabled && PrivacyRights.cameraFound && PrivacyRights.microphoneFound)
				{
					configureDevices();
				}
				else
				{
					CustomAlert.error(resourceManager.getString('myResources', 'DEVICES_NOT_ALLOWED_ERROR'));
				}
			}

			public function set cancelClickHandler(cancelFunction:Function):void
			{
				cancelCapture.addEventListener(MouseEvent.CLICK, cancelFunction);
			}

			public function set uploadClickHandler(uploadFunction:Function):void
			{
				uploadCapture.addEventListener(MouseEvent.CLICK, uploadFunction);
			}
		]]>
	</fx:Script>

	<fx:Binding source="{DataModel.getInstance().netConnected}"
				destination="onConnectionStatus"/>


	<s:SkinnableContainer id="videoBg"
						  backgroundColor="0x000000"
						  width="100%"
						  height="100%">
		<s:layout>
			<s:HorizontalLayout horizontalAlign="center"/>
		</s:layout>
		<mx:UIComponent id="videoHolder"
						width="{Math.round(videoBg.height*4/3)}"
						height="{videoBg.height}"/>
	</s:SkinnableContainer>

	<s:SkinnableContainer width="100%"
						  backgroundColor="0xCCCCCC">
		<s:HGroup paddingBottom="2"
				  paddingTop="2"
				  paddingLeft="4"
				  paddingRight="4"
				  horizontalAlign="left"
				  verticalAlign="middle"
				  width="100%"
				  gap="4">

			<skins:IconButton click="playPauseRecording()"
							  id="playPauseButton"
							  enabled="false"
							  width="20"
							  height="20"
							  cornerRadius="4"
							  skinClass="skins.IconButtonSkin"/>
			<s:HGroup width="100%"
					  horizontalAlign="right">
				<s:Label id="recordCountdown"
						 visible="false"
						 text=""/>
			</s:HGroup>
		</s:HGroup>
	</s:SkinnableContainer>
	<s:HGroup id="actionsGroup"
			  width="100%"
			  paddingBottom="10"
			  paddingLeft="10"
			  paddingRight="10"
			  paddingTop="10">
		<skins:IconButton id="cancelCapture"
					  styleName="btn-default"
					  label="{resourceManager.getString('myResources','CANCEL')}"/>
		<s:HGroup width="100%"
				  horizontalAlign="center">
			<skins:IconButton id="startStopCapture"
							  label="{resourceManager.getString('myResources', 'START_RECORDING')}"
							  cornerRadius="1"
							  skinClass="skins.IconButtonSkin"
							  click="startStopRecording()"/>
		</s:HGroup>
		<s:Button id="uploadCapture"
				  label="{resourceManager.getString('myResources', 'UPLOAD')}"
				  visible="{recordingFileName != null  &amp;&amp; !isRecording}"
				  cornerRadius="1"/>
	</s:HGroup>



</s:VGroup>
